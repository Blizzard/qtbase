From a71ccc033fe2cf1c3c58633d3bd220c52b744478 Mon Sep 17 00:00:00 2001
From: Andrew Knight <andrew.knight@digia.com>
Date: Fri, 8 Nov 2013 09:04:59 +0200
Subject: [PATCH] ANGLE: Enable D3D11 for feature level 9 cards

Enable use of ANGLE on lower-end hardware, such as Surface RT and
Windows Phone 8.

Based on https://codereview.appspot.com/12917046/

Change-Id: Ice536802e4eedc1d264abd0dd65960638fce59e4
---
 src/3rdparty/angle/src/libGLESv2/Buffer.cpp        |   8 +-
 src/3rdparty/angle/src/libGLESv2/Buffer.h          |   4 +-
 src/3rdparty/angle/src/libGLESv2/libGLESv2.cpp     |   4 +-
 .../angle/src/libGLESv2/renderer/BufferStorage.h   |   2 +-
 .../src/libGLESv2/renderer/BufferStorage11.cpp     |   9 +-
 .../angle/src/libGLESv2/renderer/BufferStorage11.h |   2 +-
 .../src/libGLESv2/renderer/BufferStorage9.cpp      |   2 +-
 .../angle/src/libGLESv2/renderer/BufferStorage9.h  |   2 +-
 .../angle/src/libGLESv2/renderer/Image11.cpp       |   7 +-
 .../angle/src/libGLESv2/renderer/IndexBuffer11.cpp |   4 +-
 .../src/libGLESv2/renderer/RenderStateCache.cpp    |   3 +-
 .../angle/src/libGLESv2/renderer/Renderer11.cpp    | 288 +++++++++++++++------
 .../angle/src/libGLESv2/renderer/Renderer11.h      |   2 +
 .../angle/src/libGLESv2/renderer/SwapChain11.cpp   |   7 +-
 .../src/libGLESv2/renderer/TextureStorage11.cpp    |   8 +-
 .../src/libGLESv2/renderer/renderer11_utils.cpp    |   4 +-
 .../src/libGLESv2/renderer/renderer11_utils.h      |   2 +-
 .../src/libGLESv2/renderer/shaders/Clear11.hlsl    |   4 +
 src/angle/src/libGLESv2/libGLESv2.pro              |   8 +-
 19 files changed, 260 insertions(+), 110 deletions(-)

diff --git a/src/3rdparty/angle/src/libGLESv2/Buffer.cpp b/src/3rdparty/angle/src/libGLESv2/Buffer.cpp
index c007d5d..40baa95 100644
--- a/src/3rdparty/angle/src/libGLESv2/Buffer.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/Buffer.cpp
@@ -37,11 +37,11 @@ Buffer::~Buffer()
     delete mStaticIndexBuffer;
 }
 
-void Buffer::bufferData(const void *data, GLsizeiptr size, GLenum usage)
+void Buffer::bufferData(const void *data, GLsizeiptr size, GLenum usage, GLenum target)
 {
     mBufferStorage->clear();
     mIndexRangeCache.clear();
-    mBufferStorage->setData(data, size, 0);
+    mBufferStorage->setData(data, size, 0, target);
 
     mUsage = usage;
 
@@ -54,9 +54,9 @@ void Buffer::bufferData(const void *data, GLsizeiptr size, GLenum usage)
     }
 }
 
-void Buffer::bufferSubData(const void *data, GLsizeiptr size, GLintptr offset)
+void Buffer::bufferSubData(const void *data, GLsizeiptr size, GLintptr offset, GLenum target)
 {
-    mBufferStorage->setData(data, size, offset);
+    mBufferStorage->setData(data, size, offset, target);
     mIndexRangeCache.invalidateRange(offset, size);
 
     if ((mStaticVertexBuffer && mStaticVertexBuffer->getBufferSize() != 0) || (mStaticIndexBuffer && mStaticIndexBuffer->getBufferSize() != 0))
diff --git a/src/3rdparty/angle/src/libGLESv2/Buffer.h b/src/3rdparty/angle/src/libGLESv2/Buffer.h
index 4048f4b..9b86b97 100644
--- a/src/3rdparty/angle/src/libGLESv2/Buffer.h
+++ b/src/3rdparty/angle/src/libGLESv2/Buffer.h
@@ -33,8 +33,8 @@ class Buffer : public RefCountObject
 
     virtual ~Buffer();
 
-    void bufferData(const void *data, GLsizeiptr size, GLenum usage);
-    void bufferSubData(const void *data, GLsizeiptr size, GLintptr offset);
+    void bufferData(const void *data, GLsizeiptr size, GLenum usage, GLenum target);
+    void bufferSubData(const void *data, GLsizeiptr size, GLintptr offset, GLenum target);
 
     GLenum usage() const;
 
diff --git a/src/3rdparty/angle/src/libGLESv2/libGLESv2.cpp b/src/3rdparty/angle/src/libGLESv2/libGLESv2.cpp
index 320bbcc..91719f8 100644
--- a/src/3rdparty/angle/src/libGLESv2/libGLESv2.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/libGLESv2.cpp
@@ -758,7 +758,7 @@ void __stdcall glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data,
                 return gl::error(GL_INVALID_OPERATION);
             }
 
-            buffer->bufferData(data, size, usage);
+            buffer->bufferData(data, size, usage, target);
         }
     }
     catch(std::bad_alloc&)
@@ -812,7 +812,7 @@ void __stdcall glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size,
                 return gl::error(GL_INVALID_VALUE);
             }
 
-            buffer->bufferSubData(data, size, offset);
+            buffer->bufferSubData(data, size, offset, target);
         }
     }
     catch(std::bad_alloc&)
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage.h b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage.h
index ace1a11..14a8c27 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage.h
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage.h
@@ -22,7 +22,7 @@ class BufferStorage
 
     // The data returned is only guaranteed valid until next non-const method.
     virtual void *getData() = 0;
-    virtual void setData(const void* data, unsigned int size, unsigned int offset) = 0;
+    virtual void setData(const void* data, unsigned int size, unsigned int offset, unsigned int target) = 0;
     virtual void clear() = 0;
     virtual unsigned int getSize() const = 0;
     virtual bool supportsDirectBinding() const = 0;
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.cpp
index 3647d8a..2f694db 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.cpp
@@ -131,7 +131,7 @@ void *BufferStorage11::getData()
     return mResolvedData;
 }
 
-void BufferStorage11::setData(const void* data, unsigned int size, unsigned int offset)
+void BufferStorage11::setData(const void* data, unsigned int size, unsigned int offset, unsigned int target)
 {
     ID3D11Device *device = mRenderer->getDevice();
     ID3D11DeviceContext *context = mRenderer->getDeviceContext();
@@ -201,7 +201,10 @@ void BufferStorage11::setData(const void* data, unsigned int size, unsigned int
         D3D11_BUFFER_DESC bufferDesc;
         bufferDesc.ByteWidth = requiredBufferSize;
         bufferDesc.Usage = D3D11_USAGE_DEFAULT;
-        bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_INDEX_BUFFER;
+        if (mRenderer->getFeatureLevel() > D3D_FEATURE_LEVEL_9_3)
+            bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_INDEX_BUFFER;
+        else
+            bufferDesc.BindFlags = target == GL_ARRAY_BUFFER ? D3D11_BIND_VERTEX_BUFFER : D3D11_BIND_INDEX_BUFFER;
         bufferDesc.CPUAccessFlags = 0;
         bufferDesc.MiscFlags = 0;
         bufferDesc.StructureByteStride = 0;
@@ -324,7 +327,7 @@ unsigned int BufferStorage11::getSize() const
 
 bool BufferStorage11::supportsDirectBinding() const
 {
-    return true;
+    return mRenderer->getFeatureLevel() >= D3D_FEATURE_LEVEL_10_0;
 }
 
 void BufferStorage11::markBufferUsage()
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.h b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.h
index b62348b..c948962 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.h
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage11.h
@@ -24,7 +24,7 @@ class BufferStorage11 : public BufferStorage
     static BufferStorage11 *makeBufferStorage11(BufferStorage *bufferStorage);
 
     virtual void *getData();
-    virtual void setData(const void* data, unsigned int size, unsigned int offset);
+    virtual void setData(const void* data, unsigned int size, unsigned int offset, unsigned int target);
     virtual void clear();
     virtual unsigned int getSize() const;
     virtual bool supportsDirectBinding() const;
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.cpp
index e69e7a8..57fd29b 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.cpp
@@ -36,7 +36,7 @@ void *BufferStorage9::getData()
     return mMemory;
 }
 
-void BufferStorage9::setData(const void* data, unsigned int size, unsigned int offset)
+void BufferStorage9::setData(const void* data, unsigned int size, unsigned int offset, unsigned int)
 {
     if (!mMemory || offset + size > mAllocatedSize)
     {
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.h b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.h
index 3e80396..82ae577 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.h
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/BufferStorage9.h
@@ -23,7 +23,7 @@ class BufferStorage9 : public BufferStorage
     static BufferStorage9 *makeBufferStorage9(BufferStorage *bufferStorage);
 
     virtual void *getData();
-    virtual void setData(const void* data, unsigned int size, unsigned int offset);
+    virtual void setData(const void* data, unsigned int size, unsigned int offset, unsigned int target = 0);
     virtual void clear();
     virtual unsigned int getSize() const;
     virtual bool supportsDirectBinding() const;
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/Image11.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/Image11.cpp
index 09c8922..81e9e9e 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/Image11.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/Image11.cpp
@@ -136,7 +136,7 @@ bool Image11::redefine(Renderer *renderer, GLint internalformat, GLsizei width,
         mHeight = height;
         mInternalFormat = internalformat;
         // compute the d3d format that will be used
-        mDXGIFormat = gl_d3d11::ConvertTextureFormat(internalformat);
+        mDXGIFormat = gl_d3d11::ConvertTextureFormat(internalformat, mRenderer->getFeatureLevel());
         mActualFormat = d3d11_gl::ConvertTextureInternalFormat(mDXGIFormat);
 
         if (mStagingTexture)
@@ -185,7 +185,10 @@ void Image11::loadData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei heig
     switch (mInternalFormat)
     {
       case GL_ALPHA8_EXT:
-        loadAlphaDataToNative(width, height, inputPitch, input, mappedImage.RowPitch, offsetMappedData);
+        if (mRenderer->getFeatureLevel() >= D3D_FEATURE_LEVEL_10_0)
+            loadAlphaDataToNative(width, height, inputPitch, input, mappedImage.RowPitch, offsetMappedData);
+        else
+            loadAlphaDataToBGRA(width, height, inputPitch, input, mappedImage.RowPitch, offsetMappedData);
         break;
       case GL_LUMINANCE8_EXT:
         loadLuminanceDataToNativeOrBGRA(width, height, inputPitch, input, mappedImage.RowPitch, offsetMappedData, false);
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/IndexBuffer11.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/IndexBuffer11.cpp
index 66604c4..36a62ad 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/IndexBuffer11.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/IndexBuffer11.cpp
@@ -170,7 +170,7 @@ DXGI_FORMAT IndexBuffer11::getIndexFormat() const
     {
       case GL_UNSIGNED_BYTE:    return DXGI_FORMAT_R16_UINT;
       case GL_UNSIGNED_SHORT:   return DXGI_FORMAT_R16_UINT;
-      case GL_UNSIGNED_INT:     return DXGI_FORMAT_R32_UINT;
+      case GL_UNSIGNED_INT:     return mRenderer->get32BitIndexSupport() ? DXGI_FORMAT_R32_UINT : DXGI_FORMAT_R16_UINT;
       default: UNREACHABLE();   return DXGI_FORMAT_UNKNOWN;
     }
 }
@@ -180,4 +180,4 @@ ID3D11Buffer *IndexBuffer11::getBuffer() const
     return mBuffer;
 }
 
-}
\ No newline at end of file
+}
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/RenderStateCache.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/RenderStateCache.cpp
index b3111af..fd388df 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/RenderStateCache.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/RenderStateCache.cpp
@@ -387,7 +387,8 @@ ID3D11SamplerState *RenderStateCache::getSamplerState(const gl::SamplerState &sa
         samplerDesc.BorderColor[2] = 0.0f;
         samplerDesc.BorderColor[3] = 0.0f;
         samplerDesc.MinLOD = gl_d3d11::ConvertMinLOD(samplerState.minFilter, samplerState.lodOffset);
-        samplerDesc.MaxLOD = gl_d3d11::ConvertMaxLOD(samplerState.minFilter, samplerState.lodOffset);
+        samplerDesc.MaxLOD = mDevice->GetFeatureLevel() >= D3D_FEATURE_LEVEL_10_0
+                ? gl_d3d11::ConvertMaxLOD(samplerState.minFilter, samplerState.lodOffset) : FLT_MAX;
 
         ID3D11SamplerState *dx11SamplerState = NULL;
         HRESULT result = mDevice->CreateSamplerState(&samplerDesc, &dx11SamplerState);
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.cpp
index d04467b..f83e9e9 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.cpp
@@ -160,9 +160,13 @@ EGLint Renderer11::initialize()
 
     D3D_FEATURE_LEVEL featureLevels[] =
     {
+        D3D_FEATURE_LEVEL_11_1,
         D3D_FEATURE_LEVEL_11_0,
         D3D_FEATURE_LEVEL_10_1,
         D3D_FEATURE_LEVEL_10_0,
+        D3D_FEATURE_LEVEL_9_3,
+        D3D_FEATURE_LEVEL_9_2,
+        D3D_FEATURE_LEVEL_9_1,
     };
 
     HRESULT result = S_OK;
@@ -1114,6 +1118,43 @@ void Renderer11::drawElements(GLenum mode, GLsizei count, GLenum type, const GLv
     }
 }
 
+template <typename T>
+static void drawLineLoopIndexed(T *data, GLenum type, const GLvoid *indices, GLsizei count)
+{
+    switch (type)
+    {
+      case GL_NONE:   // Non-indexed draw
+        for (int i = 0; i < count; i++)
+        {
+            data[i] = i;
+        }
+        data[count] = 0;
+        break;
+      case GL_UNSIGNED_BYTE:
+        for (int i = 0; i < count; i++)
+        {
+            data[i] = static_cast<const GLubyte*>(indices)[i];
+        }
+        data[count] = static_cast<const GLubyte*>(indices)[0];
+        break;
+      case GL_UNSIGNED_SHORT:
+        for (int i = 0; i < count; i++)
+        {
+            data[i] = static_cast<const GLushort*>(indices)[i];
+        }
+        data[count] = static_cast<const GLushort*>(indices)[0];
+        break;
+      case GL_UNSIGNED_INT:
+        for (int i = 0; i < count; i++)
+        {
+            data[i] = static_cast<const GLuint*>(indices)[i];
+        }
+        data[count] = static_cast<const GLuint*>(indices)[0];
+        break;
+      default: UNREACHABLE();
+    }
+}
+
 void Renderer11::drawLineLoop(GLsizei count, GLenum type, const GLvoid *indices, int minIndex, gl::Buffer *elementArrayBuffer)
 {
     // Get the raw indices for an indexed draw
@@ -1162,59 +1203,71 @@ void Renderer11::drawLineLoop(GLsizei count, GLenum type, const GLvoid *indices,
         return gl::error(GL_OUT_OF_MEMORY);
     }
 
-    unsigned int *data = reinterpret_cast<unsigned int*>(mappedMemory);
+    if (get32BitIndexSupport())
+        drawLineLoopIndexed(reinterpret_cast<unsigned int*>(mappedMemory), type, indices, count);
+    else
+        drawLineLoopIndexed(reinterpret_cast<unsigned short*>(mappedMemory), type, indices, count);
+
     unsigned int indexBufferOffset = offset;
 
+    if (!mLineLoopIB->unmapBuffer())
+    {
+        ERR("Could not unmap index buffer for GL_LINE_LOOP.");
+        return gl::error(GL_OUT_OF_MEMORY);
+    }
+
+    if (mAppliedIBSerial != mLineLoopIB->getSerial() || mAppliedIBOffset != indexBufferOffset)
+    {
+        IndexBuffer11 *indexBuffer = IndexBuffer11::makeIndexBuffer11(mLineLoopIB->getIndexBuffer());
+
+        mDeviceContext->IASetIndexBuffer(indexBuffer->getBuffer(), indexBuffer->getIndexFormat(), indexBufferOffset);
+        mAppliedIBSerial = mLineLoopIB->getSerial();
+        mAppliedStorageIBSerial = 0;
+        mAppliedIBOffset = indexBufferOffset;
+    }
+
+    mDeviceContext->DrawIndexed(count + 1, 0, -minIndex);
+}
+
+template <typename T>
+static void drawTriangleFanIndexed(T *data, GLenum type, const GLvoid *indices, unsigned int numTris)
+{
     switch (type)
     {
       case GL_NONE:   // Non-indexed draw
-        for (int i = 0; i < count; i++)
+        for (unsigned int i = 0; i < numTris; i++)
         {
-            data[i] = i;
+            data[i*3 + 0] = 0;
+            data[i*3 + 1] = i + 1;
+            data[i*3 + 2] = i + 2;
         }
-        data[count] = 0;
         break;
       case GL_UNSIGNED_BYTE:
-        for (int i = 0; i < count; i++)
+        for (unsigned int i = 0; i < numTris; i++)
         {
-            data[i] = static_cast<const GLubyte*>(indices)[i];
+            data[i*3 + 0] = static_cast<const GLubyte*>(indices)[0];
+            data[i*3 + 1] = static_cast<const GLubyte*>(indices)[i + 1];
+            data[i*3 + 2] = static_cast<const GLubyte*>(indices)[i + 2];
         }
-        data[count] = static_cast<const GLubyte*>(indices)[0];
         break;
       case GL_UNSIGNED_SHORT:
-        for (int i = 0; i < count; i++)
+        for (unsigned int i = 0; i < numTris; i++)
         {
-            data[i] = static_cast<const GLushort*>(indices)[i];
+            data[i*3 + 0] = static_cast<const GLushort*>(indices)[0];
+            data[i*3 + 1] = static_cast<const GLushort*>(indices)[i + 1];
+            data[i*3 + 2] = static_cast<const GLushort*>(indices)[i + 2];
         }
-        data[count] = static_cast<const GLushort*>(indices)[0];
         break;
       case GL_UNSIGNED_INT:
-        for (int i = 0; i < count; i++)
+        for (unsigned int i = 0; i < numTris; i++)
         {
-            data[i] = static_cast<const GLuint*>(indices)[i];
+            data[i*3 + 0] = static_cast<const GLuint*>(indices)[0];
+            data[i*3 + 1] = static_cast<const GLuint*>(indices)[i + 1];
+            data[i*3 + 2] = static_cast<const GLuint*>(indices)[i + 2];
         }
-        data[count] = static_cast<const GLuint*>(indices)[0];
         break;
       default: UNREACHABLE();
     }
-
-    if (!mLineLoopIB->unmapBuffer())
-    {
-        ERR("Could not unmap index buffer for GL_LINE_LOOP.");
-        return gl::error(GL_OUT_OF_MEMORY);
-    }
-
-    if (mAppliedIBSerial != mLineLoopIB->getSerial() || mAppliedIBOffset != indexBufferOffset)
-    {
-        IndexBuffer11 *indexBuffer = IndexBuffer11::makeIndexBuffer11(mLineLoopIB->getIndexBuffer());
-
-        mDeviceContext->IASetIndexBuffer(indexBuffer->getBuffer(), indexBuffer->getIndexFormat(), indexBufferOffset);
-        mAppliedIBSerial = mLineLoopIB->getSerial();
-        mAppliedStorageIBSerial = 0;
-        mAppliedIBOffset = indexBufferOffset;
-    }
-
-    mDeviceContext->DrawIndexed(count + 1, 0, -minIndex);
 }
 
 void Renderer11::drawTriangleFan(GLsizei count, GLenum type, const GLvoid *indices, int minIndex, gl::Buffer *elementArrayBuffer, int instances)
@@ -1267,45 +1320,12 @@ void Renderer11::drawTriangleFan(GLsizei count, GLenum type, const GLvoid *indic
         return gl::error(GL_OUT_OF_MEMORY);
     }
 
-    unsigned int *data = reinterpret_cast<unsigned int*>(mappedMemory);
-    unsigned int indexBufferOffset = offset;
+    if (get32BitIndexSupport())
+        drawTriangleFanIndexed(reinterpret_cast<unsigned int*>(mappedMemory), type, indices, numTris);
+    else
+        drawTriangleFanIndexed(reinterpret_cast<unsigned short*>(mappedMemory), type, indices, numTris);
 
-    switch (type)
-    {
-      case GL_NONE:   // Non-indexed draw
-        for (unsigned int i = 0; i < numTris; i++)
-        {
-            data[i*3 + 0] = 0;
-            data[i*3 + 1] = i + 1;
-            data[i*3 + 2] = i + 2;
-        }
-        break;
-      case GL_UNSIGNED_BYTE:
-        for (unsigned int i = 0; i < numTris; i++)
-        {
-            data[i*3 + 0] = static_cast<const GLubyte*>(indices)[0];
-            data[i*3 + 1] = static_cast<const GLubyte*>(indices)[i + 1];
-            data[i*3 + 2] = static_cast<const GLubyte*>(indices)[i + 2];
-        }
-        break;
-      case GL_UNSIGNED_SHORT:
-        for (unsigned int i = 0; i < numTris; i++)
-        {
-            data[i*3 + 0] = static_cast<const GLushort*>(indices)[0];
-            data[i*3 + 1] = static_cast<const GLushort*>(indices)[i + 1];
-            data[i*3 + 2] = static_cast<const GLushort*>(indices)[i + 2];
-        }
-        break;
-      case GL_UNSIGNED_INT:
-        for (unsigned int i = 0; i < numTris; i++)
-        {
-            data[i*3 + 0] = static_cast<const GLuint*>(indices)[0];
-            data[i*3 + 1] = static_cast<const GLuint*>(indices)[i + 1];
-            data[i*3 + 2] = static_cast<const GLuint*>(indices)[i + 2];
-        }
-        break;
-      default: UNREACHABLE();
-    }
+    unsigned int indexBufferOffset = offset;
 
     if (!mTriangleFanIB->unmapBuffer())
     {
@@ -1515,7 +1535,7 @@ void Renderer11::applyUniforms(gl::ProgramBinary *programBinary, gl::UniformArra
     }
 
     // needed for the point sprite geometry shader
-    if (mCurrentGeometryConstantBuffer != mDriverConstantBufferPS)
+    if (mFeatureLevel >= D3D_FEATURE_LEVEL_10_0 && mCurrentGeometryConstantBuffer != mDriverConstantBufferPS)
     {
         mDeviceContext->GSSetConstantBuffers(0, 1, &mDriverConstantBufferPS);
         mCurrentGeometryConstantBuffer = mDriverConstantBufferPS;
@@ -1929,9 +1949,13 @@ bool Renderer11::testDeviceResettable()
 
     D3D_FEATURE_LEVEL featureLevels[] =
     {
+        D3D_FEATURE_LEVEL_11_1,
         D3D_FEATURE_LEVEL_11_0,
         D3D_FEATURE_LEVEL_10_1,
         D3D_FEATURE_LEVEL_10_0,
+        D3D_FEATURE_LEVEL_9_3,
+        D3D_FEATURE_LEVEL_9_2,
+        D3D_FEATURE_LEVEL_9_1,
     };
 
     ID3D11Device* dummyDevice;
@@ -2110,11 +2134,17 @@ float Renderer11::getTextureMaxAnisotropy() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
         return D3D11_MAX_MAXANISOTROPY;
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
         return D3D10_MAX_MAXANISOTROPY;
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+        return 16;
+      case D3D_FEATURE_LEVEL_9_1:
+        return D3D_FL9_1_DEFAULT_MAX_ANISOTROPY;
       default: UNREACHABLE();
         return 0;
     }
@@ -2129,11 +2159,17 @@ Range Renderer11::getViewportBounds() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
         return Range(D3D11_VIEWPORT_BOUNDS_MIN, D3D11_VIEWPORT_BOUNDS_MAX);
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
         return Range(D3D10_VIEWPORT_BOUNDS_MIN, D3D10_VIEWPORT_BOUNDS_MAX);
+      case D3D_FEATURE_LEVEL_9_3:
+        return Range(D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION * -2, D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION * 2);
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return Range(D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION * -2, D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION * 2);
       default: UNREACHABLE();
         return Range(0, 0);
     }
@@ -2144,10 +2180,15 @@ unsigned int Renderer11::getMaxVertexTextureImageUnits() const
     META_ASSERT(MAX_TEXTURE_IMAGE_UNITS_VTF_SM4 <= gl::IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS);
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
         return MAX_TEXTURE_IMAGE_UNITS_VTF_SM4;
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return 0;
       default: UNREACHABLE();
         return 0;
     }
@@ -2171,15 +2212,41 @@ unsigned int Renderer11::getReservedFragmentUniformVectors() const
 unsigned int Renderer11::getMaxVertexUniformVectors() const
 {
     META_ASSERT(MAX_VERTEX_UNIFORM_VECTORS_D3D11 <= D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT);
-    ASSERT(mFeatureLevel >= D3D_FEATURE_LEVEL_10_0);
-    return MAX_VERTEX_UNIFORM_VECTORS_D3D11;
+    switch (mFeatureLevel)
+    {
+      case D3D_FEATURE_LEVEL_11_1:
+      case D3D_FEATURE_LEVEL_11_0:
+      case D3D_FEATURE_LEVEL_10_1:
+      case D3D_FEATURE_LEVEL_10_0:
+        return MAX_VERTEX_UNIFORM_VECTORS_D3D11;
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return MAX_VERTEX_UNIFORM_VECTORS_D3D9;
+      default:
+        UNIMPLEMENTED();
+        return 0;
+    }
 }
 
 unsigned int Renderer11::getMaxFragmentUniformVectors() const
 {
     META_ASSERT(MAX_FRAGMENT_UNIFORM_VECTORS_D3D11 <= D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT);
-    ASSERT(mFeatureLevel >= D3D_FEATURE_LEVEL_10_0);
-    return MAX_FRAGMENT_UNIFORM_VECTORS_D3D11;
+    switch (mFeatureLevel)
+    {
+      case D3D_FEATURE_LEVEL_11_1:
+      case D3D_FEATURE_LEVEL_11_0:
+      case D3D_FEATURE_LEVEL_10_1:
+      case D3D_FEATURE_LEVEL_10_0:
+        return MAX_FRAGMENT_UNIFORM_VECTORS_D3D11;
+      case D3D_FEATURE_LEVEL_9_3:
+        return 221;
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return 29;
+      default: UNREACHABLE();
+        return 0;
+    }
 }
 
 unsigned int Renderer11::getMaxVaryingVectors() const
@@ -2187,11 +2254,17 @@ unsigned int Renderer11::getMaxVaryingVectors() const
     META_ASSERT(gl::IMPLEMENTATION_MAX_VARYING_VECTORS == D3D11_VS_OUTPUT_REGISTER_COUNT);
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
         return D3D11_VS_OUTPUT_REGISTER_COUNT;
       case D3D_FEATURE_LEVEL_10_1:
+        return D3D10_1_VS_OUTPUT_REGISTER_COUNT;
       case D3D_FEATURE_LEVEL_10_0:
         return D3D10_VS_OUTPUT_REGISTER_COUNT;
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return 8;
       default: UNREACHABLE();
         return 0;
     }
@@ -2201,10 +2274,15 @@ bool Renderer11::getNonPower2TextureSupport() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
         return true;
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return false;
       default: UNREACHABLE();
         return false;
     }
@@ -2214,10 +2292,15 @@ bool Renderer11::getOcclusionQuerySupport() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
         return true;
+      case D3D_FEATURE_LEVEL_9_1:
+        return false;
       default: UNREACHABLE();
         return false;
     }
@@ -2227,10 +2310,15 @@ bool Renderer11::getInstancingSupport() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
+      case D3D_FEATURE_LEVEL_9_3:
         return true;
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return false;
       default: UNREACHABLE();
         return false;
     }
@@ -2248,10 +2336,15 @@ bool Renderer11::getDerivativeInstructionSupport() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
+      case D3D_FEATURE_LEVEL_9_3:
         return true;
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return false;
       default: UNREACHABLE();
         return false;
     }
@@ -2267,9 +2360,13 @@ int Renderer11::getMajorShaderModel() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0: return D3D11_SHADER_MAJOR_VERSION;   // 5
       case D3D_FEATURE_LEVEL_10_1: return D3D10_1_SHADER_MAJOR_VERSION; // 4
       case D3D_FEATURE_LEVEL_10_0: return D3D10_SHADER_MAJOR_VERSION;   // 4
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:  return 4; // SM4 level 9, but treat as 4
       default: UNREACHABLE();      return 0;
     }
 }
@@ -2278,9 +2375,13 @@ int Renderer11::getMinorShaderModel() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0: return D3D11_SHADER_MINOR_VERSION;   // 0
       case D3D_FEATURE_LEVEL_10_1: return D3D10_1_SHADER_MINOR_VERSION; // 1
       case D3D_FEATURE_LEVEL_10_0: return D3D10_SHADER_MINOR_VERSION;   // 0
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:  return 0;
       default: UNREACHABLE();      return 0;
     }
 }
@@ -2301,11 +2402,17 @@ int Renderer11::getMaxViewportDimension() const
 
     switch (mFeatureLevel)
     {
-      case D3D_FEATURE_LEVEL_11_0: 
+      case D3D_FEATURE_LEVEL_11_1:
+      case D3D_FEATURE_LEVEL_11_0:
         return D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION;   // 16384
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0: 
         return D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION;   // 8192
+      case D3D_FEATURE_LEVEL_9_3:
+        return D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION; // 4096
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION; // 2048
       default: UNREACHABLE();      
         return 0;
     }
@@ -2315,9 +2422,13 @@ int Renderer11::getMaxTextureWidth() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0: return D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION;   // 16384
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0: return D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION;   // 8192
+      case D3D_FEATURE_LEVEL_9_3: return D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION; // 4096
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1: return D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION; // 2048
       default: UNREACHABLE();      return 0;
     }
 }
@@ -2326,9 +2437,13 @@ int Renderer11::getMaxTextureHeight() const
 {
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0: return D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION;   // 16384
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0: return D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION;   // 8192
+      case D3D_FEATURE_LEVEL_9_3: return D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION; // 4096
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1: return D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION; // 2048
       default: UNREACHABLE();      return 0;
     }
 }
@@ -2337,9 +2452,13 @@ bool Renderer11::get32BitIndexSupport() const
 {
     switch (mFeatureLevel)
     {
-      case D3D_FEATURE_LEVEL_11_0: 
+      case D3D_FEATURE_LEVEL_11_1:
+      case D3D_FEATURE_LEVEL_11_0:
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0: return D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP >= 32;   // true
+      case D3D_FEATURE_LEVEL_9_3:
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:  return false;
       default: UNREACHABLE();      return false;
     }
 }
@@ -2386,14 +2505,22 @@ unsigned int Renderer11::getMaxRenderTargets() const
 {
     META_ASSERT(D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT <= gl::IMPLEMENTATION_MAX_DRAW_BUFFERS);
     META_ASSERT(D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT <= gl::IMPLEMENTATION_MAX_DRAW_BUFFERS);
+    META_ASSERT(D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT <= gl::IMPLEMENTATION_MAX_DRAW_BUFFERS);
+    META_ASSERT(D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT <= gl::IMPLEMENTATION_MAX_DRAW_BUFFERS);
 
     switch (mFeatureLevel)
     {
+      case D3D_FEATURE_LEVEL_11_1:
       case D3D_FEATURE_LEVEL_11_0:
         return D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT;  // 8
       case D3D_FEATURE_LEVEL_10_1:
       case D3D_FEATURE_LEVEL_10_0:
         return D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT;  // 8
+      case D3D_FEATURE_LEVEL_9_3:
+        return D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT; // 4
+      case D3D_FEATURE_LEVEL_9_2:
+      case D3D_FEATURE_LEVEL_9_1:
+        return D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT; // 1
       default:
         UNREACHABLE();
         return 1;
@@ -2821,7 +2948,7 @@ ShaderExecutable *Renderer11::loadExecutable(const void *function, size_t length
 
 ShaderExecutable *Renderer11::compileToExecutable(gl::InfoLog &infoLog, const char *shaderHLSL, rx::ShaderType type)
 {
-    const char *profile = NULL;
+    std::string profile;
 
     switch (type)
     {
@@ -2839,7 +2966,12 @@ ShaderExecutable *Renderer11::compileToExecutable(gl::InfoLog &infoLog, const ch
         return NULL;
     }
 
-    ID3DBlob *binary = (ID3DBlob*)compileToBinary(infoLog, shaderHLSL, profile, D3DCOMPILE_OPTIMIZATION_LEVEL0, false);
+    if (mFeatureLevel == D3D_FEATURE_LEVEL_9_3)
+        profile += "_level_9_3";
+    else if (mFeatureLevel == D3D_FEATURE_LEVEL_9_2 || mFeatureLevel == D3D_FEATURE_LEVEL_9_1)
+        profile += "_level_9_1";
+
+    ID3DBlob *binary = (ID3DBlob*)compileToBinary(infoLog, shaderHLSL, profile.c_str(), D3DCOMPILE_OPTIMIZATION_LEVEL0, false);
     if (!binary)
         return NULL;
 
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.h b/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.h
index a7f5a39..433945d 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.h
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/Renderer11.h
@@ -32,6 +32,7 @@ class StreamingIndexBufferInterface;
 
 enum
 {
+    MAX_VERTEX_UNIFORM_VECTORS_D3D9 = 254,
     MAX_VERTEX_UNIFORM_VECTORS_D3D11 = 1024,
     MAX_FRAGMENT_UNIFORM_VECTORS_D3D11 = 1024
 };
@@ -177,6 +178,7 @@ class Renderer11 : public Renderer
     ID3D11Device *getDevice() { return mDevice; }
     ID3D11DeviceContext *getDeviceContext() { return mDeviceContext; };
     IDXGIFactory *getDxgiFactory() { return mDxgiFactory; };
+    D3D_FEATURE_LEVEL getFeatureLevel() const { return mFeatureLevel; }
 
     bool getRenderTargetResource(gl::Renderbuffer *colorbuffer, unsigned int *subresourceIndex, ID3D11Texture2D **resource);
     void unapplyRenderTargets();
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/SwapChain11.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/SwapChain11.cpp
index 0797fd7..9770772 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/SwapChain11.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/SwapChain11.cpp
@@ -500,12 +500,17 @@ EGLint SwapChain11::reset(int backbufferWidth, int backbufferHeight, EGLint swap
         ASSERT(SUCCEEDED(result));
 
         DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {0};
-        swapChainDesc.BufferCount = 2;
         swapChainDesc.Format = gl_d3d11::ConvertRenderbufferFormat(mBackBufferFormat);
         swapChainDesc.Width = backbufferWidth;
         swapChainDesc.Height = backbufferHeight;
         swapChainDesc.Stereo = FALSE;
+#if !defined(ANGLE_OS_WINPHONE)
+        swapChainDesc.BufferCount = 2;
         swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
+#else
+        swapChainDesc.BufferCount = 1;
+        swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+#endif
 #endif
 
         swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/TextureStorage11.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/TextureStorage11.cpp
index 408b48e..32a407a 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/TextureStorage11.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/TextureStorage11.cpp
@@ -222,14 +222,14 @@ TextureStorage11_2D::TextureStorage11_2D(Renderer *renderer, SwapChain11 *swapch
 }
 
 TextureStorage11_2D::TextureStorage11_2D(Renderer *renderer, int levels, GLenum internalformat, GLenum usage, bool forceRenderable, GLsizei width, GLsizei height)
-    : TextureStorage11(renderer, GetTextureBindFlags(gl_d3d11::ConvertTextureFormat(internalformat), usage, forceRenderable))
+    : TextureStorage11(renderer, GetTextureBindFlags(gl_d3d11::ConvertTextureFormat(internalformat, Renderer11::makeRenderer11(renderer)->getFeatureLevel()), usage, forceRenderable))
 {
     for (unsigned int i = 0; i < gl::IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
     {
         mRenderTarget[i] = NULL;
     }
 
-    DXGI_FORMAT convertedFormat = gl_d3d11::ConvertTextureFormat(internalformat);
+    DXGI_FORMAT convertedFormat = gl_d3d11::ConvertTextureFormat(internalformat, Renderer11::makeRenderer11(renderer)->getFeatureLevel());
     if (d3d11::IsDepthStencilFormat(convertedFormat))
     {
         mTextureFormat = d3d11::GetDepthTextureFormat(convertedFormat);
@@ -440,7 +440,7 @@ void TextureStorage11_2D::generateMipmap(int level)
 }
 
 TextureStorage11_Cube::TextureStorage11_Cube(Renderer *renderer, int levels, GLenum internalformat, GLenum usage, bool forceRenderable, int size)
-    : TextureStorage11(renderer, GetTextureBindFlags(gl_d3d11::ConvertTextureFormat(internalformat), usage, forceRenderable))
+    : TextureStorage11(renderer, GetTextureBindFlags(gl_d3d11::ConvertTextureFormat(internalformat, Renderer11::makeRenderer11(renderer)->getFeatureLevel()), usage, forceRenderable))
 {
     for (unsigned int i = 0; i < 6; i++)
     {
@@ -450,7 +450,7 @@ TextureStorage11_Cube::TextureStorage11_Cube(Renderer *renderer, int levels, GLe
         }
     }
 
-    DXGI_FORMAT convertedFormat = gl_d3d11::ConvertTextureFormat(internalformat);
+    DXGI_FORMAT convertedFormat = gl_d3d11::ConvertTextureFormat(internalformat, Renderer11::makeRenderer11(renderer)->getFeatureLevel());
     if (d3d11::IsDepthStencilFormat(convertedFormat))
     {
         mTextureFormat = d3d11::GetDepthTextureFormat(convertedFormat);
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.cpp b/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.cpp
index 13800da..0624a61 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.cpp
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.cpp
@@ -329,7 +329,7 @@ DXGI_FORMAT ConvertRenderbufferFormat(GLenum format)
     return DXGI_FORMAT_R8G8B8A8_UNORM;
 }
 
-DXGI_FORMAT ConvertTextureFormat(GLenum internalformat)
+DXGI_FORMAT ConvertTextureFormat(GLenum internalformat, D3D_FEATURE_LEVEL featureLevel)
 {
     switch (internalformat)
     {
@@ -342,7 +342,7 @@ DXGI_FORMAT ConvertTextureFormat(GLenum internalformat)
       case GL_LUMINANCE8_ALPHA8_EXT:
         return DXGI_FORMAT_R8G8B8A8_UNORM;
       case GL_ALPHA8_EXT:
-        return DXGI_FORMAT_A8_UNORM;
+        return featureLevel >= D3D_FEATURE_LEVEL_10_0 ? DXGI_FORMAT_A8_UNORM : DXGI_FORMAT_B8G8R8A8_UNORM;
       case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
       case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
         return DXGI_FORMAT_BC1_UNORM;
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.h b/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.h
index 1bc48c1..70ad4fe 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.h
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/renderer11_utils.h
@@ -32,7 +32,7 @@ FLOAT ConvertMinLOD(GLenum minFilter, unsigned int lodOffset);
 FLOAT ConvertMaxLOD(GLenum minFilter, unsigned int lodOffset);
 
 DXGI_FORMAT ConvertRenderbufferFormat(GLenum format);
-DXGI_FORMAT ConvertTextureFormat(GLenum format);
+DXGI_FORMAT ConvertTextureFormat(GLenum format, D3D_FEATURE_LEVEL featureLevel);
 }
 
 namespace d3d11_gl
diff --git a/src/3rdparty/angle/src/libGLESv2/renderer/shaders/Clear11.hlsl b/src/3rdparty/angle/src/libGLESv2/renderer/shaders/Clear11.hlsl
index 042ac69..cb132dc 100644
--- a/src/3rdparty/angle/src/libGLESv2/renderer/shaders/Clear11.hlsl
+++ b/src/3rdparty/angle/src/libGLESv2/renderer/shaders/Clear11.hlsl
@@ -12,10 +12,12 @@ struct PS_OutputMultiple
 	float4 color1 : SV_TARGET1;
 	float4 color2 : SV_TARGET2;
 	float4 color3 : SV_TARGET3;
+#ifdef SM4
 	float4 color4 : SV_TARGET4;
 	float4 color5 : SV_TARGET5;
 	float4 color6 : SV_TARGET6;
 	float4 color7 : SV_TARGET7;
+#endif
 };
 
 PS_OutputMultiple PS_ClearMultiple(in float4 inPosition : SV_POSITION, in float4 inColor : COLOR)
@@ -25,10 +27,12 @@ PS_OutputMultiple PS_ClearMultiple(in float4 inPosition : SV_POSITION, in float4
 	outColor.color1 = inColor;
 	outColor.color2 = inColor;
 	outColor.color3 = inColor;
+#ifdef SM4
 	outColor.color4 = inColor;
 	outColor.color5 = inColor;
 	outColor.color6 = inColor;
 	outColor.color7 = inColor;
+#endif
 	return outColor;
 }
 
diff --git a/src/angle/src/libGLESv2/libGLESv2.pro b/src/angle/src/libGLESv2/libGLESv2.pro
index ff2f888..b39ce78 100644
--- a/src/angle/src/libGLESv2/libGLESv2.pro
+++ b/src/angle/src/libGLESv2/libGLESv2.pro
@@ -190,7 +190,7 @@ for (ps, PIXEL_SHADERS_BLIT) {
     QMAKE_EXTRA_COMPILERS += fxc_ps_$${ps}
 }
 for (ps, PIXEL_SHADERS_PASSTHROUGH) {
-    fxc_ps_$${ps}.commands = $$FXC /nologo /E PS_$$ps /T ps_4_0 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
+    fxc_ps_$${ps}.commands = $$FXC /nologo /E PS_$$ps /T ps_4_0_level_9_1 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
     fxc_ps_$${ps}.output = $$SHADER_DIR/$${ps}11ps.h
     fxc_ps_$${ps}.input = PASSTHROUGH_INPUT
     fxc_ps_$${ps}.dependency_type = TYPE_C
@@ -199,7 +199,7 @@ for (ps, PIXEL_SHADERS_PASSTHROUGH) {
     QMAKE_EXTRA_COMPILERS += fxc_ps_$${ps}
 }
 for (ps, PIXEL_SHADERS_CLEAR) {
-    fxc_ps_$${ps}.commands = $$FXC /nologo /E PS_$$ps /T ps_4_0 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
+    fxc_ps_$${ps}.commands = $$FXC /nologo /E PS_$$ps /T ps_4_0_level_9_1 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
     fxc_ps_$${ps}.output = $$SHADER_DIR/$${ps}11ps.h
     fxc_ps_$${ps}.input = CLEAR_INPUT
     fxc_ps_$${ps}.dependency_type = TYPE_C
@@ -217,7 +217,7 @@ for (vs, VERTEX_SHADERS_BLIT) {
     QMAKE_EXTRA_COMPILERS += fxc_vs_$${vs}
 }
 for (vs, VERTEX_SHADERS_PASSTHROUGH) {
-    fxc_vs_$${vs}.commands = $$FXC /nologo /E VS_$$vs /T vs_4_0 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
+    fxc_vs_$${vs}.commands = $$FXC /nologo /E VS_$$vs /T vs_4_0_level_9_1 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
     fxc_vs_$${vs}.output = $$SHADER_DIR/$${vs}11vs.h
     fxc_vs_$${vs}.input = PASSTHROUGH_INPUT
     fxc_vs_$${vs}.dependency_type = TYPE_C
@@ -226,7 +226,7 @@ for (vs, VERTEX_SHADERS_PASSTHROUGH) {
     QMAKE_EXTRA_COMPILERS += fxc_vs_$${vs}
 }
 for (vs, VERTEX_SHADERS_CLEAR) {
-    fxc_vs_$${vs}.commands = $$FXC /nologo /E VS_$$vs /T vs_4_0 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
+    fxc_vs_$${vs}.commands = $$FXC /nologo /E VS_$$vs /T vs_4_0_level_9_1 /Fh ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
     fxc_vs_$${vs}.output = $$SHADER_DIR/$${vs}11vs.h
     fxc_vs_$${vs}.input = CLEAR_INPUT
     fxc_vs_$${vs}.dependency_type = TYPE_C
-- 
1.8.4.msysgit.0

